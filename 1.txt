save直接发送语句
persist  注解里常用，发送时不直接、
Oracle三层嵌套语句
笛卡尔积数据库
hibernate创建对象，hibernate已经被jboss收购了
声明式事务优点
乐观锁 版本号cx
cailiang522
18845801231cl
资源库名字：蔡亮
pojo对象符合bean （有get' set'方法，）有业务处理方法（saveAction deleteAction）这种类称之为pojo类或pojo对象
sprin工厂是有监听器来的
ssh  spring是管理框架，不占mvc层 hibernate占M层，struts 占vc两层
Struts 自己定义的类会先调用方法，返回。
序列化：把JAVA对象以二进流的形式存在本地磁盘
...可变类型，放一个也行，放两个也行
100ofer 拉钩 boss
内连接和外连接的区别：内连接的是只有符合条件的显示。外连接不符合的一边也全显示。
内连接效率高  Oracle 左连接和右连接可以用（+）
****** JDBC 中的resultset 就用到了游标
sleep
同步锁方法。Threadlocal锁参数
-------------------------------------------------------------------------
模板模式：把相同的东西放到一个模板（相同的东西只写一遍)，然后匿名内部类

get 如果报错会出现空指针
load 会延迟加载 使用的是代理模式 如果报错会是：对象没有找到
抽象类有构造器但不创建对象
equals相同 ，对象相同，哈希码一定相同   对的
哈希码相同，对象不一定相同
n个对象就有n个this
super子类调用父类的成员方法
Inputstream是抽象类
serializable 是一个空接口，没有方法
问？怎样使主键不重复？
答：可以使用uuid，把uuid放到CRC32版本里
----------------------------------------------------->>>>>>>>>>>>>>>>>>>
继承
随机数是0-1之间
碰到throw 就相当于return try{下面的代码就不走了}，然后catch里面的代码还是走的
i++  是先赋值再加一。
int i=1；
int j=i++；  （此时 j还是1 ，i在先给j赋值之后，才自身加一，说明i就变成了2）
++i是先加一再赋值。


------------------------------------------------------
查看linux 环境下的jdk 安装目录  which java

进程是内存，线程是CPU
依赖注入的方式：set（按名称和按类型） 构造器注入
mysql的分页效率极高，mysql有多种引擎，因为有的引擎支持事务，有的不支持
selcet 中where 效率比having高。where是从右向左，先带条件再查询
大数据量不建议用hibernate 因为hibernate动态生成，使用cglib打开封装上
用mybits可以用存储过程，省略网络流量
自律模式自己new自己用。堆中只有一个对象
存储过程和函数，存储过程不需要有返回值 in out inout
服务器内存溢出解决办法：注意死循环

商业管理：进货管理：商品表，进货表，进货详情，库存表。价格跟踪

你觉得遇到最大的问题：用户的需求有变，需要加一个redis


--------------------------------------------------------------
map做分词，reduce做计算

------------------------------------------------------
由远往进结。要在一个事务
结完之后break
按金额，内部按单子结

-------------------------------------
hadoop是离线查询 ，不是当前的操作，当前操作可以进行，之前的数据也可以查询，就是离线型 









oracle  函数和存储过程，唯一区别是，函数有返回值。存储过程没有返回值

String 为什么不可变  ：： 因为String 底层是一个  String数组，使用Final修饰的。而finanl修饰的变量为常量，所以其地址是不可变的。但是为什么？String 数组里的值不能改变？
因为String 没有给我们提供一个可以修改或拿出数组的方法
